# Solidity Recursive Call Vulnerability Example
A dapple project simulating a simple recursive call vulnerability

# Try it out yourself
Install dapple with:
```
$ npm install -g dapple
```
Clone the repo:
```
$ git clone https://github.com/karlfloersch/recursive-call-vulnerability-example.git
```
`cd` into the repo:
```
$ cd recursive-call-vulnerability-example
```
Run dapple test:
```
$ dapple test
```

The output should look something like:
```
...
  LOG:  logs
  LOG:    val: Sent funds
  LOG:  logs
  LOG:    val: Sent funds
  LOG:  logs
  LOG:    val: Sent funds
  LOG:  logs
  LOG:    val: Sent funds
  LOG:  logs
  LOG:    val: Sent funds
  LOG:  logs
  LOG:    val: Sent funds
  LOG:  logs
  LOG:    val: Sent funds
  LOG:  logs
  LOG:    val: Attack Complete
  LOG:  logs
  LOG:    val: Attacker Balance:
  LOG:  log_uint
  LOG:    val: 545
  LOG:  logs
  LOG:    val: DAO Balance:
  LOG:  log_uint
  LOG:    val: 5
  Passed!


Summary
  Passed all 1 tests!
```

Woah! It looks like you stole a ton of ETH! 

Open DumbDAO.sol and look at [line 10](https://github.com/karlfloersch/recursive-call-vulnerability-example/blob/master/contracts/DumbDAO.sol#L10). That line is sending the ETH to the Attack contract. Notice that it is sending the ETH before flagging the transaction as being sent. This leaves the DAO vulnerable.
Try swapping `addr.call.value(10)();` for `isSent = true;` and then run dapple test. You should see that the attack has now been foiled.


Enjoy!
